.TH "src/queue.c" 3 "Fri Jan 25 2013" "PiThread" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/queue.c \- 
.SH SYNOPSIS
.br
.PP
\fC#include <stdlib\&.h>\fP
.br
\fC#include <queue\&.h>\fP
.br

.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBLOCK_QUEUE\fP(q)   \fBPICC_acquire\fP(q->lock);"
.br
.ti -1c
.RI "#define \fBRELEASE_QUEUE\fP(q)   \fBPICC_release\fP(q->lock, NULL);"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPICC_QueueCell\fP * \fBPICC_create_queue_cell\fP (\fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_ReadyQueue\fP * \fBPICC_create_ready_queue\fP (\fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "void \fBPICC_ready_queue_push\fP (\fBPICC_ReadyQueue\fP *rq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "void \fBPICC_ready_queue_add\fP (\fBPICC_ReadyQueue\fP *rq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_PiThread\fP * \fBPICC_ready_queue_pop\fP (\fBPICC_ReadyQueue\fP *rq)"
.br
.ti -1c
.RI "int \fBPICC_ready_queue_size\fP (\fBPICC_ReadyQueue\fP *rq)"
.br
.ti -1c
.RI "\fBPICC_WaitQueue\fP * \fBPICC_create_wait_queue\fP (\fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "void \fBPICC_wait_queue_push\fP (\fBPICC_WaitQueue\fP *wq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_PiThread\fP * \fBPICC_wait_queue_fetch\fP (\fBPICC_WaitQueue\fP *wq, \fBPICC_PiThread\fP *pt)"
.br
.ti -1c
.RI "void \fBPICC_wait_queue_push_old\fP (\fBPICC_WaitQueue\fP *wq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_PiThread\fP * \fBPICC_wait_queue_pop_old\fP (\fBPICC_WaitQueue\fP *wq)"
.br
.ti -1c
.RI "int \fBPICC_wait_queue_size\fP (\fBPICC_WaitQueue\fP *wq)"
.br
.ti -1c
.RI "int \fBPICC_wait_queue_max_active\fP (\fBPICC_WaitQueue\fP *wq)"
.br
.ti -1c
.RI "void \fBPICC_wait_queue_max_active_reset\fP (\fBPICC_WaitQueue\fP *wq)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Concurrent ready and wait queues implementation
.PP
This project is released under MIT License\&.
.PP
\fBAuthor:\fP
.RS 4
MickaÃ«l MENU 
.PP
Maxence WO 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define LOCK_QUEUE(q)   \fBPICC_acquire\fP(q->lock);"

.SS "#define RELEASE_QUEUE(q)   \fBPICC_release\fP(q->lock, NULL);"

.SH "Function Documentation"
.PP 
.SS "\fBPICC_QueueCell\fP* PICC_create_queue_cell (\fBPICC_Error\fP *error)"
Allocates a new queue cell\&.
.PP
\fBReturns:\fP
.RS 4
Allocated queue cell 
.RE
.PP

.SS "\fBPICC_ReadyQueue\fP* PICC_create_ready_queue (\fBPICC_Error\fP *error)"
Creates a new empty ready queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIerror\fP Error stack 
.RE
.PP

.SS "\fBPICC_WaitQueue\fP* PICC_create_wait_queue (\fBPICC_Error\fP *error)"
Creates a new empty wait queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIerror\fP Error stack 
.RE
.PP

.SS "void PICC_ready_queue_add (\fBPICC_ReadyQueue\fP *rq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
Adds a PiThread at the end of the given ready queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIrq\fP Ready queue 
.br
\fIpt\fP PiThread 
.RE
.PP

.SS "\fBPICC_PiThread\fP* PICC_ready_queue_pop (\fBPICC_ReadyQueue\fP *rq)\fC [read]\fP"
Pops a PiThread from the given ready queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIrq\fP Ready queue 
.RE
.PP
\fBReturns:\fP
.RS 4
Popped PiThread 
.RE
.PP

.SS "void PICC_ready_queue_push (\fBPICC_ReadyQueue\fP *rq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
Pushes a PiThread on the given ready queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIrq\fP Ready queue 
.br
\fIpt\fP PiThread 
.RE
.PP

.SS "int PICC_ready_queue_size (\fBPICC_ReadyQueue\fP *rq)"
Returns the size of the given ready queue\&.
.PP
\fBReturns:\fP
.RS 4
Size of the ready queue 
.RE
.PP

.SS "\fBPICC_PiThread\fP* PICC_wait_queue_fetch (\fBPICC_WaitQueue\fP *wq, \fBPICC_PiThread\fP *pt)\fC [read]\fP"
Gets a given PiThread from the wait queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.br
\fIpt\fP PiThread 
.RE
.PP

.SS "int PICC_wait_queue_max_active (\fBPICC_WaitQueue\fP *wq)"
Returns the size of the active wait queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.RE
.PP

.SS "void PICC_wait_queue_max_active_reset (\fBPICC_WaitQueue\fP *wq)"
Resets the active wait queue by pushing its cells in the old wait queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.RE
.PP

.SS "\fBPICC_PiThread\fP* PICC_wait_queue_pop_old (\fBPICC_WaitQueue\fP *wq)\fC [read]\fP"
Pops a PiThread from the old wait queue\&.
.PP
WARNING: WHY THE POP IS TAKING THE END OF THE QUEUE AND NOT THE HEAD ?
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.RE
.PP

.SS "void PICC_wait_queue_push (\fBPICC_WaitQueue\fP *wq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
Pushes a PiThread on the given wait queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.br
\fIpt\fP PiThread 
.RE
.PP

.SS "void PICC_wait_queue_push_old (\fBPICC_WaitQueue\fP *wq, \fBPICC_PiThread\fP *pt, \fBPICC_Error\fP *error)"
Pushes a PiThread in the old wait queue\&.
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.br
\fIpt\fP PiThread 
.br
\fIerror\fP Error stack 
.RE
.PP

.SS "int PICC_wait_queue_size (\fBPICC_WaitQueue\fP *wq)"
Returns the size of the active + old wait queues\&.
.PP
\fBParameters:\fP
.RS 4
\fIwq\fP Wait queue 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for PiThread from the source code\&.
