.TH "include/set.h" 3 "Fri Jan 25 2013" "PiThread" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/set.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <channel\&.h>\fP
.br
\fC#include <commit\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_PICC_CommitL\fP"
.br
.ti -1c
.RI "struct \fB_PICC_KnownsList\fP"
.br
.ti -1c
.RI "struct \fB_PICC_Set\fP"
.br
.ti -1c
.RI "struct \fB_PICC_SetElement\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPICC_SET_ADD\fP(s, e)   \fBPICC_set_add\fP(s, e, NULL)"
.br
.ti -1c
.RI "#define \fBPICC_SET_IS_EMPTY\fP(s)   \fBPICC_set_is_empty\fP(s)"
.br
.ti -1c
.RI "#define \fBPICC_SET_MEM\fP(s, e)   \fBPICC_set_mem\fP(s, e)"
.br
.ti -1c
.RI "#define \fBPICC_SET_MAP\fP(s, f)   \fBPICC_set_map\fP(s, f)"
.br
.ti -1c
.RI "#define \fBPICC_SET_ITER\fP(s, f)   \fBPICC_set_iter\fP(s, f);"
.br
.ti -1c
.RI "#define \fBPICC_SET_INTER\fP(s1, s2)   \fBPICC_set_inter\fP(s1, s2);"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef enum \fB_PICC_SetType\fP \fBPICC_SetType\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_CommitL\fP \fBPICC_CommitL\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_KnownsList\fP \fBPICC_KnownsList\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_Set\fP \fBPICC_Set\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_SetElement\fP \fBPICC_SetElement\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_PICC_SetType\fP { \fBPICC_COMMIT\fP, \fBPICC_KNOWNS\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPICC_Commit\fP * \fBPICC_clone_commit\fP (\fBPICC_Commit\fP *c)"
.br
.ti -1c
.RI "\fBPICC_Knowns\fP * \fBPICC_clone_knowns\fP (\fBPICC_Knowns\fP *k)"
.br
.ti -1c
.RI "bool \fBPICC_cmp_commit\fP (\fBPICC_Commit\fP *c, \fBPICC_Commit\fP *c2, \fBPICC_Error\fP *err)"
.br
.ti -1c
.RI "bool \fBPICC_cmp_knowns\fP (\fBPICC_Knowns\fP *k, \fBPICC_Knowns\fP *k2, \fBPICC_Error\fP *err)"
.br
.ti -1c
.RI "bool \fBPICC_set_mem_knowns\fP (\fBPICC_Set\fP *s, \fBPICC_Knowns\fP *k, \fBPICC_Error\fP *err)"
.br
.ti -1c
.RI "bool \fBPICC_set_mem_commit\fP (\fBPICC_Set\fP *s, \fBPICC_Commit\fP *c, \fBPICC_Error\fP *err)"
.br
.ti -1c
.RI "void \fBPICC_set_add_commit\fP (\fBPICC_Set\fP *s, \fBPICC_Commit\fP *elem)"
.br
.ti -1c
.RI "void \fBPICC_set_add_knowns\fP (\fBPICC_Set\fP *s, \fBPICC_Knowns\fP *elem)"
.br
.ti -1c
.RI "void \fBPICC_set_map_commit\fP (\fBPICC_Set\fP *s, void(*func)(\fBPICC_Commit\fP *))"
.br
.ti -1c
.RI "void \fBPICC_set_map_knowns\fP (\fBPICC_Set\fP *s, void(*func)(\fBPICC_Knowns\fP *))"
.br
.ti -1c
.RI "\fBPICC_Set\fP * \fBPICC_set_make\fP (\fBPICC_SetType\fP type)"
.br
.ti -1c
.RI "void \fBPICC_set_add\fP (\fBPICC_Set\fP *s, \fBPICC_SetElement\fP *elem, \fBPICC_Error\fP *err)"
.br
.ti -1c
.RI "bool \fBPICC_set_mem\fP (\fBPICC_Set\fP *s, \fBPICC_SetElement\fP *elem, \fBPICC_Error\fP *err)"
.br
.ti -1c
.RI "bool \fBPICC_set_is_empty\fP (\fBPICC_Set\fP *s)"
.br
.ti -1c
.RI "void \fBPICC_set_map\fP (\fBPICC_Set\fP *s, void(*func)(void *))"
.br
.ti -1c
.RI "void \fBPICC_set_destroy\fP (\fBPICC_Set\fP *s)"
.br
.ti -1c
.RI "\fBPICC_Set\fP * \fBPICC_set_inter_commit\fP (\fBPICC_Set\fP *s1, \fBPICC_Set\fP *s2)"
.br
.ti -1c
.RI "\fBPICC_Set\fP * \fBPICC_set_inter_knowns\fP (\fBPICC_Set\fP *s1, \fBPICC_Set\fP *s2)"
.br
.ti -1c
.RI "\fBPICC_Set\fP * \fBPICC_set_inter\fP (\fBPICC_Set\fP *s1, \fBPICC_Set\fP *s2)"
.br
.ti -1c
.RI "void \fBPICC_set_iter_commit\fP (\fBPICC_Set\fP *s, void(*func)(\fBPICC_Commit\fP *arg))"
.br
.ti -1c
.RI "void \fBPICC_set_iter_knowns\fP (\fBPICC_Set\fP *s, void(*func)(\fBPICC_Knowns\fP *arg))"
.br
.ti -1c
.RI "void \fBPICC_set_iter\fP (\fBPICC_Set\fP *s, void(*func)(void *arg))"
.br
.ti -1c
.RI "int \fBPICC_test_generic_sets\fP ()"
.br
.in -1c
.SH "Detailed Description"
.PP 
Provides several function headers and structures to generic sets\&.
.PP
This project is released under MIT License\&.
.PP
\fBAuthor:\fP
.RS 4
Maxence WO 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define PICC_SET_ADD(s, e)   \fBPICC_set_add\fP(s, e, NULL)"

.SS "#define PICC_SET_INTER(s1, s2)   \fBPICC_set_inter\fP(s1, s2);"

.SS "#define PICC_SET_IS_EMPTY(s)   \fBPICC_set_is_empty\fP(s)"

.SS "#define PICC_SET_ITER(s, f)   \fBPICC_set_iter\fP(s, f);"

.SS "#define PICC_SET_MAP(s, f)   \fBPICC_set_map\fP(s, f)"

.SS "#define PICC_SET_MEM(s, e)   \fBPICC_set_mem\fP(s, e)"

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_PICC_CommitL\fP \fBPICC_CommitL\fP"

.SS "typedef struct \fB_PICC_KnownsList\fP \fBPICC_KnownsList\fP"

.SS "typedef struct \fB_PICC_Set\fP  \fBPICC_Set\fP"

.SS "typedef struct \fB_PICC_SetElement\fP  \fBPICC_SetElement\fP"

.SS "typedef enum \fB_PICC_SetType\fP  \fBPICC_SetType\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fB_PICC_SetType\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPICC_COMMIT \fP\fP
.TP
\fB\fIPICC_KNOWNS \fP\fP
.SH "Function Documentation"
.PP 
.SS "\fBPICC_Commit\fP* PICC_clone_commit (\fBPICC_Commit\fP *c)"

.SS "\fBPICC_Knowns\fP* PICC_clone_knowns (\fBPICC_Knowns\fP *k)"

.SS "bool PICC_cmp_commit (\fBPICC_Commit\fP *c, \fBPICC_Commit\fP *c2, \fBPICC_Error\fP *err)"
Compare 2 commits
.PP
\fBParameters:\fP
.RS 4
\fIc\fP Commit 
.br
\fIc2\fP Commit 
.br
\fIerr\fP Error 
.RE
.PP
\fBReturns:\fP
.RS 4
res true if commits are the same else false 
.RE
.PP

.SS "bool PICC_cmp_knowns (\fBPICC_Knowns\fP *k, \fBPICC_Knowns\fP *k2, \fBPICC_Error\fP *err)"
Compare 2 knowns
.PP
\fBParameters:\fP
.RS 4
\fIk\fP Knowns 
.br
\fIk2\fP Knowns 
.br
\fIerr\fP Error 
.RE
.PP
\fBReturns:\fP
.RS 4
res true if knowns are the same else false 
.RE
.PP

.SS "void PICC_set_add (\fBPICC_Set\fP *s, \fBPICC_SetElement\fP *elem, \fBPICC_Error\fP *err)"
Add an element to a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIelem\fP SetElement 
.br
\fIerr\fP Error 
.RE
.PP

.SS "void PICC_set_add_commit (\fBPICC_Set\fP *s, \fBPICC_Commit\fP *elem)"
Add a commit to a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIelem\fP Commit 
.RE
.PP

.SS "void PICC_set_add_knowns (\fBPICC_Set\fP *s, \fBPICC_Knowns\fP *elem)"
Add a knowns to a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIelem\fP Knowns 
.RE
.PP

.SS "void PICC_set_destroy (\fBPICC_Set\fP *s)"
Free a Set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set to free 
.RE
.PP

.SS "\fBPICC_Set\fP* PICC_set_inter (\fBPICC_Set\fP *s1, \fBPICC_Set\fP *s2)"

.SS "\fBPICC_Set\fP* PICC_set_inter_commit (\fBPICC_Set\fP *s1, \fBPICC_Set\fP *s2)"

.SS "\fBPICC_Set\fP* PICC_set_inter_knowns (\fBPICC_Set\fP *s1, \fBPICC_Set\fP *s2)"

.SS "bool PICC_set_is_empty (\fBPICC_Set\fP *s)"
Check if a set is empty
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.RE
.PP
\fBReturns:\fP
.RS 4
bool true if the set is empty else false 
.RE
.PP

.SS "void PICC_set_iter (\fBPICC_Set\fP *s, void(*)(void *arg)func)"

.SS "void PICC_set_iter_commit (\fBPICC_Set\fP *s, void(*)(\fBPICC_Commit\fP *arg)func)"

.SS "void PICC_set_iter_knowns (\fBPICC_Set\fP *s, void(*)(\fBPICC_Knowns\fP *arg)func)"

.SS "\fBPICC_Set\fP* PICC_set_make (\fBPICC_SetType\fPtype)"
Initialize a set
.PP
\fBParameters:\fP
.RS 4
\fItype\fP SetType 
.RE
.PP
\fBReturns:\fP
.RS 4
s return an initialized set 
.RE
.PP

.SS "void PICC_set_map (\fBPICC_Set\fP *s, void(*)(void *)func)"
Apply a fonction to all elements of a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIfunc\fP Function that takes a commit or a knowns as parameter 
.RE
.PP

.SS "void PICC_set_map_commit (\fBPICC_Set\fP *s, void(*)(\fBPICC_Commit\fP *)func)"
Apply a fonction to all elements of a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIfunc\fP Function that takes a commit parameter 
.RE
.PP

.SS "void PICC_set_map_knowns (\fBPICC_Set\fP *s, void(*)(\fBPICC_Knowns\fP *)func)"
Apply a fonction to all elements of a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIfunc\fP Function that takes a knowns parameter 
.RE
.PP

.SS "bool PICC_set_mem (\fBPICC_Set\fP *s, \fBPICC_SetElement\fP *elem, \fBPICC_Error\fP *err)"
Check if an element is in a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIelem\fP SetElement 
.br
\fIerr\fP Error 
.RE
.PP
\fBReturns:\fP
.RS 4
bool true if an element is in a set 
.RE
.PP

.SS "bool PICC_set_mem_commit (\fBPICC_Set\fP *s, \fBPICC_Commit\fP *c, \fBPICC_Error\fP *err)"
Search if a commit is in a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIc\fP Commit 
.br
\fIerr\fP Error 
.RE
.PP
\fBReturns:\fP
.RS 4
res true if c is in s 
.RE
.PP

.SS "bool PICC_set_mem_knowns (\fBPICC_Set\fP *s, \fBPICC_Knowns\fP *k, \fBPICC_Error\fP *err)"
Search if a knowns is in a set
.PP
\fBParameters:\fP
.RS 4
\fIs\fP Set 
.br
\fIk\fP knowns 
.br
\fIerr\fP Error 
.RE
.PP
\fBReturns:\fP
.RS 4
res true if k is in s 
.RE
.PP

.SS "int PICC_test_generic_sets ()"

.SH "Author"
.PP 
Generated automatically by Doxygen for PiThread from the source code\&.
