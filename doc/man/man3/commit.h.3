.TH "include/commit.h" 3 "Fri Feb 8 2013" "PiThread" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/commit.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include <pi_thread\&.h>\fP
.br
\fC#include <symbols\&.h>\fP
.br
\fC#include <channel\&.h>\fP
.br
\fC#include <value\&.h>\fP
.br
\fC#include <error\&.h>\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fB_PICC_InCommit\fP"
.br
.ti -1c
.RI "struct \fB_PICC_OutCommit\fP"
.br
.ti -1c
.RI "struct \fB_PICC_Commit\fP"
.br
.ti -1c
.RI "struct \fB_PICC_CommitListElement\fP"
.br
.ti -1c
.RI "struct \fB_PICC_CommitList\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef struct \fB_PICC_Value\fP *( \fBPICC_EvalFunction\fP )(struct \fB_PICC_PiThread\fP *)"
.br
.ti -1c
.RI "typedef enum \fB_PICC_CommitType\fP \fBPICC_CommitType\fP"
.br
.ti -1c
.RI "typedef enum \fB_PICC_CommitStatus\fP \fBPICC_CommitStatus\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_InCommit\fP \fBPICC_InCommit\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_OutCommit\fP \fBPICC_OutCommit\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_Commit\fP \fBPICC_Commit\fP"
.br
.ti -1c
.RI "typedef struct 
.br
\fB_PICC_CommitListElement\fP \fBPICC_CommitListElement\fP"
.br
.ti -1c
.RI "typedef struct \fB_PICC_CommitList\fP \fBPICC_CommitList\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fB_PICC_CommitType\fP { \fBPICC_IN_COMMIT\fP, \fBPICC_OUT_COMMIT\fP }"
.br
.ti -1c
.RI "enum \fB_PICC_CommitStatus\fP { \fBPICC_CANNOT_ACQUIRE\fP, \fBPICC_VALID_COMMIT\fP, \fBPICC_INVALID_COMMIT\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBPICC_Commit\fP * \fBPICC_create_commitment\fP (\fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_CommitList\fP * \fBPICC_create_commit_list\fP (\fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_CommitListElement\fP * \fBPICC_create_commit_list_element\fP (\fBPICC_Commit\fP *commit, \fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "void \fBPICC_register_output_commitment\fP (struct \fB_PICC_PiThread\fP *p, struct \fB_PICC_Channel\fP *ch, \fBPICC_EvalFunction\fP *eval, \fBPICC_Label\fP cont_pc)"
.br
.ti -1c
.RI "void \fBPICC_register_input_commitment\fP (struct \fB_PICC_PiThread\fP *p, struct \fB_PICC_Channel\fP *ch, int refvar, \fBPICC_Label\fP cont_pc)"
.br
.ti -1c
.RI "bool \fBPICC_is_valid_commit\fP (\fBPICC_Commit\fP *commit)"
.br
.ti -1c
.RI "bool \fBPICC_commit_list_is_empty\fP (\fBPICC_CommitList\fP *clist)"
.br
.ti -1c
.RI "void \fBPICC_commit_list_add\fP (\fBPICC_CommitList\fP *clist, \fBPICC_Commit\fP *c, \fBPICC_Error\fP *error)"
.br
.ti -1c
.RI "\fBPICC_Commit\fP * \fBPICC_fetch_input_commitment\fP (struct \fB_PICC_Channel\fP *ch)"
.br
.ti -1c
.RI "\fBPICC_Commit\fP * \fBPICC_fetch_output_commitment\fP (struct \fB_PICC_Channel\fP *ch)"
.br
.ti -1c
.RI "void \fBPICC_Commit_inv\fP (\fBPICC_Commit\fP *commit)"
.br
.RI "\fIChecks commit invariant\&. \fP"
.ti -1c
.RI "void \fBPICC_CommitListElement_inv\fP (\fBPICC_CommitListElement\fP *elem)"
.br
.ti -1c
.RI "void \fBPICC_CommitList_inv\fP (\fBPICC_CommitList\fP *list)"
.br
.ti -1c
.RI "void \fBPICC_Refvar_inv\fP (int refvar)"
.br
.ti -1c
.RI "void \fBPICC_EvalFunction_inv\fP (\fBPICC_EvalFunction\fP eval)"
.br
.ti -1c
.RI "void \fBPICC_Label_inv\fP (\fBPICC_Label\fP cont_pc)"
.br
.in -1c
.SH "Detailed Description"
.PP 
Commits\&.
.PP
This project is released under MIT License\&.
.PP
\fBAuthor:\fP
.RS 4
Mickaël MENU 
.PP
Maxence WO 
.PP
Joël HING 
.RE
.PP

.SH "Typedef Documentation"
.PP 
.SS "typedef struct \fB_PICC_Commit\fP  \fBPICC_Commit\fP"
The commitment common part 
.SS "typedef struct \fB_PICC_CommitList\fP  \fBPICC_CommitList\fP"
The commit list type 
.SS "typedef struct \fB_PICC_CommitListElement\fP  \fBPICC_CommitListElement\fP"
The type of an element of a commit list 
.SS "typedef enum \fB_PICC_CommitStatus\fP  \fBPICC_CommitStatus\fP"
The status of the commitment 
.SS "typedef enum \fB_PICC_CommitType\fP  \fBPICC_CommitType\fP"
The type of the commitment 
.SS "typedef struct \fB_PICC_Value\fP*( PICC_EvalFunction)(struct \fB_PICC_PiThread\fP *)\fC [read]\fP"
TODO see spec 
.SS "typedef struct \fB_PICC_InCommit\fP  \fBPICC_InCommit\fP"
The input commitment specific part 
.SS "typedef struct \fB_PICC_OutCommit\fP  \fBPICC_OutCommit\fP"
The output commitment specific part 
.PP
\fBInvariant:\fP
.RS 4
eval_func != null 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fB_PICC_CommitStatus\fP"
The status of the commitment 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPICC_CANNOT_ACQUIRE \fP\fP
.TP
\fB\fIPICC_VALID_COMMIT \fP\fP
.TP
\fB\fIPICC_INVALID_COMMIT \fP\fP
.SS "enum \fB_PICC_CommitType\fP"
The type of the commitment 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIPICC_IN_COMMIT \fP\fP
Designes an input commit 
.TP
\fB\fIPICC_OUT_COMMIT \fP\fP
Designes an output commit 
.SH "Function Documentation"
.PP 
.SS "void PICC_Commit_inv (\fBPICC_Commit\fP *commit)"

.PP
Checks commit invariant\&. \fBInvariant:\fP
.RS 4
thread != null && clock != null && clockval != null && channel != null && content != null 
.RE
.PP
\fBInvariant:\fP
.RS 4
cont_pc > 0 
.RE
.PP

.SS "void PICC_commit_list_add (\fBPICC_CommitList\fP *clist, \fBPICC_Commit\fP *commit, \fBPICC_Error\fP *error)"
Adds the given element at the end of the commit list\&.
.PP
\fBPrecondition:\fP
.RS 4
clist != NULL 
.RE
.PP
\fBPrecondition:\fP
.RS 4
commit != NULL
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist->size = clist_at_pre->size + 1 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist->tail->commit = commit 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist->tail->next = NULL
.RE
.PP
\fBParameters:\fP
.RS 4
\fIclist\fP Commit list 
.br
\fIcommit\fP Commit to add 
.br
\fIerror\fP Error stack 
.RE
.PP

.SS "bool PICC_commit_list_is_empty (\fBPICC_CommitList\fP *clist)"
Returns whether a commit list is empty\&.
.PP
\fBPrecondition:\fP
.RS 4
clist != NULL
.RE
.PP
\fBPostcondition:\fP
.RS 4
if clist->size = 0 , res = true else res = false
.RE
.PP
\fBParameters:\fP
.RS 4
\fIclist\fP Commit list to check 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the commit list is empty\&. 
.RE
.PP

.SS "void PICC_CommitList_inv (\fBPICC_CommitList\fP *list)"
Checks commit list invariant\&.
.PP
\fBInvariant:\fP
.RS 4
if list->size = 0, list->head = NULL && list->tail = NULL 
.RE
.PP
\fBInvariant:\fP
.RS 4
if list->size = 1, list->head = list->tail 
.RE
.PP
\fBInvariant:\fP
.RS 4
if list->size > 1, list->head != list->tail 
.RE
.PP

.SS "void PICC_CommitListElement_inv (\fBPICC_CommitListElement\fP *elem)"
Checks commit list element invariant\&.
.PP
\fBInvariant:\fP
.RS 4
elem->commit != NULL 
.RE
.PP

.SS "\fBPICC_CommitList\fP* PICC_create_commit_list (\fBPICC_Error\fP *error)"
Creates a new commit list\&.
.PP
\fBPostcondition:\fP
.RS 4
clist != NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist->head = NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist->tail = NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist->size = 0
.RE
.PP
\fBParameters:\fP
.RS 4
\fIerror\fP Error stack 
.RE
.PP
\fBReturns:\fP
.RS 4
Created commit list 
.RE
.PP

.SS "\fBPICC_CommitListElement\fP* PICC_create_commit_list_element (\fBPICC_Commit\fP *commit, \fBPICC_Error\fP *error)"
Creates a new element of commit list\&.
.PP
\fBPrecondition:\fP
.RS 4
commit != NULL
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist_elem != NULL 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist_elem->commit = commit 
.RE
.PP
\fBPostcondition:\fP
.RS 4
clist_elem->next = NULL
.RE
.PP
\fBParameters:\fP
.RS 4
\fIcommit\fP Commit associated 
.br
\fIerror\fP Error stack 
.RE
.PP
\fBReturns:\fP
.RS 4
Created commit list element 
.RE
.PP

.SS "\fBPICC_Commit\fP* PICC_create_commitment (\fBPICC_Error\fP *error)"
Creates and returns a commitment\&.
.PP
\fBPostcondition:\fP
.RS 4
commit != null
.RE
.PP
\fBReturns:\fP
.RS 4
Created commitment 
.RE
.PP

.SS "void PICC_EvalFunction_inv (\fBPICC_EvalFunction\fPeval)"
Checks evalFunction invariant\&.
.PP
\fBInvariant:\fP
.RS 4
eval != NULL 
.RE
.PP

.SS "\fBPICC_Commit\fP* PICC_fetch_input_commitment (\fBPICC_Channel\fP *ch)"
Fetches the first element of the input commitList from a channel\&.
.PP
\fBPrecondition:\fP
.RS 4
ch != null
.RE
.PP
\fBPostcondition:\fP
.RS 4
if(c->incommits->size > 0 && PICC_is_valid_commit(PICC_commit_list_fetch(c->incommits))) PICC_fetch_input_commitment(c) = PICC_commit_list_fetch(c->incommits) 
.RE
.PP
\fBPostcondition:\fP
.RS 4
if(c->incommits->size = 0 || !(PICC_is_valid_commit(PICC_commit_list_fetch(c->incommits)))) PICC_fetch_input_commitment(c) = null
.RE
.PP
\fBParameters:\fP
.RS 4
\fIch\fP Channel to fetch the commit from 
.RE
.PP
\fBReturns:\fP
.RS 4
Fetched commit 
.RE
.PP

.SS "\fBPICC_Commit\fP* PICC_fetch_output_commitment (\fBPICC_Channel\fP *ch)"
Fetches he first element of the output commitList from a channel
.PP
\fBPrecondition:\fP
.RS 4
ch != null
.RE
.PP
\fBPostcondition:\fP
.RS 4
if(c->outcommits->size > 0 && PICC_is_valid_commit(PICC_commit_list_fetch(c->outcommits))) PICC_fetch_output_commitment(c) = PICC_commit_list_fetch(c->outcommits) 
.RE
.PP
\fBPostcondition:\fP
.RS 4
if(c->outcommits->size = 0 || !(PICC_is_valid_commit(PICC_commit_list_fetch(c->outcommits)))) PICC_fetch_output_commitment(c) = null
.RE
.PP
\fBParameters:\fP
.RS 4
\fIch\fP Channel to fetch the commit from 
.RE
.PP
\fBReturns:\fP
.RS 4
Fetched commit 
.RE
.PP

.SS "bool PICC_is_valid_commit (\fBPICC_Commit\fP *commit)"
Verifies if the given commit is valid\&.
.PP
\fBPrecondition:\fP
.RS 4
commit != null
.RE
.PP
\fBPostcondition:\fP
.RS 4
if (commit->clock == commit->thread->clock && commit->clockval == commit->thread->clock->val) valid = true else valid = false
.RE
.PP
\fBParameters:\fP
.RS 4
\fIcommit\fP Commit to validate 
.RE
.PP
\fBReturns:\fP
.RS 4
Whether the commit is valid 
.RE
.PP

.SS "void PICC_Label_inv (\fBPICC_Label\fPcont_pc)"
Checks Label invariant\&.
.PP
\fBInvariant:\fP
.RS 4
cont_pc > -1 
.RE
.PP

.SS "void PICC_Refvar_inv (intrefvar)"
Checks refvar invariant\&.
.PP
\fBInvariant:\fP
.RS 4
refvar > 0 
.RE
.PP

.SS "void PICC_register_input_commitment (\fBPICC_PiThread\fP *pt, \fBPICC_Channel\fP *ch, intrefvar, \fBPICC_Label\fPcont_pc)"
Registers an input commit with given PiThread and channel\&.
.PP
\fBPrecondition:\fP
.RS 4
pt != null && ch != null && cont_pc >= 0
.RE
.PP
\fBPostcondition:\fP
.RS 4
pt->commits->size(PICC_register_input_commitment(pt)) = pt->commits->size(pt) + 1 
.RE
.PP
\fBPostcondition:\fP
.RS 4
pt->commits->tail = commit 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->type = PICC_IN_COMMIT 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->content\&.in = in 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->thread = pt 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->channel = ch 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->cont_pc = cont_pc 
.RE
.PP
\fBPostcondition:\fP
.RS 4
in->refvar = refvar
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpt\fP PiThread associated with the commit 
.br
\fIch\fP Channel used to create the commit 
.br
\fIrefvar\fP Index of the var used to create the input commit 
.br
\fIcont_pc\fP Program counter 
.RE
.PP

.SS "void PICC_register_output_commitment (\fBPICC_PiThread\fP *pt, \fBPICC_Channel\fP *ch, \fBPICC_EvalFunction\fP *eval, \fBPICC_Label\fPcont_pc)"
Registers an output commit with given PiThread and channel\&.
.PP
\fBPrecondition:\fP
.RS 4
pt != null && ch != null && eval != null && cont_pc >= 0
.RE
.PP
\fBPostcondition:\fP
.RS 4
pt->commits->size = pt->commits->size_at_pre + 1 
.RE
.PP
\fBPostcondition:\fP
.RS 4
pt->commits->tail = commit 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->type = PICC_OUT_COMMIT 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->content\&.out = out 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->thread = pt 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->channel = ch 
.RE
.PP
\fBPostcondition:\fP
.RS 4
commit->cont_pc = cont_pc 
.RE
.PP
\fBPostcondition:\fP
.RS 4
out->eval_func = eval
.RE
.PP
\fBParameters:\fP
.RS 4
\fIpt\fP PiThread associated with the commit 
.br
\fIch\fP Channel used to create the commit 
.br
\fIeval\fP Evaluation function 
.br
\fIcont_pc\fP Programm counter 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for PiThread from the source code\&.
