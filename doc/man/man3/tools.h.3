.TH "include/tools.h" 3 "Fri Jan 25 2013" "PiThread" \" -*- nroff -*-
.ad l
.nh
.SH NAME
include/tools.h \- 
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBPICC_ALLOC\fP(var, type, error)"
.br
.ti -1c
.RI "#define \fBPICC_MALLOC\fP(var, type, error)"
.br
.ti -1c
.RI "#define \fBPICC_FREE_MUTEX\fP(m)   pthread_mutex_destroy(&m);"
.br
.ti -1c
.RI "#define \fBPICC_FREE_COMMIT\fP(c)"
.br
.ti -1c
.RI "#define \fBPICC_FREE_PITHREAD\fP(p)"
.br
.ti -1c
.RI "#define \fBPICC_FREE_VALUE\fP(v)"
.br
.ti -1c
.RI "#define \fBPICC_FREE_CHANNEL\fP(chan)"
.br
.ti -1c
.RI "#define \fBPICC_FREE_SET\fP(s)   \fBPICC_set_destroy\fP(s);"
.br
.in -1c
.SH "Detailed Description"
.PP 
Various utility functions\&.
.PP
This project is released under MIT License\&.
.PP
\fBAuthor:\fP
.RS 4
MickaÃ«l MENU 
.PP
Maxence WO 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define PICC_ALLOC(var, type, error)"
\fBValue:\fP
.PP
.nf
type *var = malloc(sizeof(type)); \
    if (var == NULL) { \
        NEW_ERROR(error, ERR_OUT_OF_MEMORY); \
    } else
.fi
.SS "#define PICC_FREE_CHANNEL(chan)"
\fBValue:\fP
.PP
.nf
PICC_FREE_MUTEX(chan->lock); \
    PICC_FREE_SET(chan->incommits); \
    PICC_FREE_SET(chan->outcommits);
.fi
.SS "#define PICC_FREE_COMMIT(c)"
\fBValue:\fP
.PP
.nf
free(c->clock); \
    free(c->clockval); \
    free(c->channel); \
    if(c->type == PICC_IN_COMMIT) \
        free(c->content\&.in); \
    else \
        free(c->content\&.out);
.fi
.SS "#define PICC_FREE_MUTEX(m)   pthread_mutex_destroy(&m);"

.SS "#define PICC_FREE_PITHREAD(p)"
\fBValue:\fP
.PP
.nf
free(p->enabled); \
    PICC_FREE_SET(p->knowns); \
    int iCount; for(iCount = 0 ; iCount<p->env_length ; iCount++) \
        PICC_FREE_VALUE(p->(*env)); \
    free(env); \
    PICC_FREE_COMMIT(p->commit); \
    PICC_FREE_SET(p->commits); \
    free(p->proc); \
    PICC_FREE_VALUE(p->val); \
    free(p->clock); \
    PICC_FREE_MUTEX(lock);
.fi
.SS "#define PICC_FREE_SET(s)   \fBPICC_set_destroy\fP(s);"

.SS "#define PICC_FREE_VALUE(v)"
\fBValue:\fP
.PP
.nf
PICC_FREE_MUTEX(v->lock); \
    if(v->kind == PICC_STRING) free(v->content\&.as_string); \
    if(v->kind == PICC_CHANNEL_VAL) PICC_FREE_CHANNEL(v->content\&.as_channel);
.fi
.SS "#define PICC_MALLOC(var, type, error)"
\fBValue:\fP
.PP
.nf
var = malloc(sizeof(type)); \
    if (var == NULL) { \
        NEW_ERROR(error, ERR_OUT_OF_MEMORY); \
    } else
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for PiThread from the source code\&.
